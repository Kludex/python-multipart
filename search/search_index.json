{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python-Multipart","text":"<p>Python-Multipart is a streaming multipart parser for Python.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#simple-example","title":"Simple Example","text":"<p>The following example shows a quick example of parsing an incoming request body in a simple WSGI application:</p> <pre><code>import python_multipart\n\ndef simple_app(environ, start_response):\n    ret = []\n\n    # The following two callbacks just append the name to the return value.\n    def on_field(field):\n        ret.append(b\"Parsed value parameter named: %s\" % (field.field_name,))\n\n    def on_file(file):\n        ret.append(b\"Parsed file parameter named: %s\" % (file.field_name,))\n\n    # Create headers object.  We need to convert from WSGI to the actual\n    # name of the header, since this library does not assume that you are\n    # using WSGI.\n    headers = {'Content-Type': environ['CONTENT_TYPE']}\n    if 'HTTP_X_FILE_NAME' in environ:\n        headers['X-File-Name'] = environ['HTTP_X_FILE_NAME']\n    if 'CONTENT_LENGTH' in environ:\n        headers['Content-Length'] = environ['CONTENT_LENGTH']\n\n    # Parse the form.\n    python_multipart.parse_form(headers, environ['wsgi.input'], on_field, on_file)\n\n    # Return something.\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    ret.append(b'\\n')\n    return ret\n\nfrom wsgiref.simple_server import make_server\nfrom wsgiref.validate import validator\n\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n</code></pre> <p>If you test this with curl, you can see that the parser works:</p> <pre><code>$ curl -ik -F \"foo=bar\" http://localhost:8123/\nHTTP/1.0 200 OK\nDate: Sun, 07 Apr 2013 01:40:52 GMT\nServer: WSGIServer/0.1 Python/2.7.3\nContent-type: text/plain\n\nParsed value parameter named: foo\n</code></pre> <p>For a more in-depth example showing how the various parts fit together, check out the next section.</p>"},{"location":"#in-depth-example","title":"In-Depth Example","text":"<p>In this section, we\u2019ll build an application that computes the SHA-256 hash of all uploaded files in a streaming manner.</p> <p>To start, we need a simple WSGI application. We could do this with a framework like Flask, Django, or Tornado, but for now let\u2019s stick to plain WSGI:</p> <pre><code>import python_multipart\n\ndef simple_app(environ, start_response):\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    return ['Hashes:\\n']\n\nfrom wsgiref.simple_server import make_server\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n</code></pre> <p>You can run this and check with curl that it works properly:</p> <pre><code>$ curl -ik http://localhost:8123/\nHTTP/1.0 200 OK\nDate: Sun, 07 Apr 2013 01:49:03 GMT\nServer: WSGIServer/0.1 Python/2.7.3\nContent-type: text/plain\nContent-Length: 8\n\nHashes:\n</code></pre> <p>Good! It works. Now, let\u2019s add some of the code that we need. What we need to do, essentially, is set up the appropriate parser and callbacks so that we can access each portion of the request as it arrives, without needing to store any parts in memory.</p> <p>We can start off by checking if we need to create the parser at all - if the Content-Type isn\u2019t multipart/form-data, then we\u2019re not going to do anything.</p> <p>The final code should look like this:</p> <pre><code>import hashlib\nimport python_multipart\nfrom python_multipart.multipart import parse_options_header\n\ndef simple_app(environ, start_response):\n    ret = []\n\n    # Python 2 doesn't have the \"nonlocal\" keyword from Python 3, so we get\n    # around it by setting attributes on a dummy object.\n    class g(object):\n        hash = None\n\n    # This is called when a new part arrives.  We create a new hash object\n    # in this callback.\n    def on_part_begin():\n        g.hash = hashlib.sha256()\n\n    # We got some data!  Update our hash.\n    def on_part_data(data, start, end):\n        g.hash.update(data[start:end])\n\n    # Our current part is done, so we can finish the hash.\n    def on_part_end():\n        ret.append(\"Part hash: %s\" % (g.hash.hexdigest(),))\n\n    # Parse the Content-Type header to get the multipart boundary.\n    content_type, params = parse_options_header(environ['CONTENT_TYPE'])\n    boundary = params.get(b'boundary')\n\n    # Callbacks dictionary.\n    callbacks = {\n        'on_part_begin': on_part_begin,\n        'on_part_data': on_part_data,\n        'on_part_end': on_part_end,\n    }\n\n    # Create the parser.\n    parser = python_multipart.MultipartParser(boundary, callbacks)\n\n    # The input stream is from the WSGI environ.\n    inp = environ['wsgi.input']\n\n    # Feed the parser with data from the request.\n    size = int(environ['CONTENT_LENGTH'])\n    while size &gt; 0:\n        to_read = min(size, 1024 * 1024)\n        data = inp.read(to_read)\n        parser.write(data)\n\n        size -= len(data)\n        if len(data) != to_read:\n            break\n\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    return ret\n\nfrom wsgiref.simple_server import make_server\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n</code></pre> <p>And you can see that this works:</p> <pre><code>$ echo \"Foo bar\" &gt; /tmp/test.txt\n$ shasum -a 256 /tmp/test.txt\n0b64696c0f7ddb9e3435341720988d5455b3b0f0724688f98ec8e6019af3d931  /tmp/test.txt\n$ curl -ik -F file=@/tmp/test.txt http://localhost:8123/\nHTTP/1.0 200 OK\nDate: Sun, 07 Apr 2013 02:09:10 GMT\nServer: WSGIServer/0.1 Python/2.7.3\nContent-type: text/plain\n\nHashes:\nPart hash: 0b64696c0f7ddb9e3435341720988d5455b3b0f0724688f98ec8e6019af3d931\n</code></pre>"},{"location":"#historical-note","title":"Historical note","text":"<p>This package used to be accessed via <code>import multipart</code>. This still works for now (with a warning) as long as the Python package <code>multipart</code> is not also installed. If both are installed, you need to use the full PyPI name <code>python_multipart</code> for this package.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#python_multipart-classes","title":"Classes","text":""},{"location":"api/#python_multipart.BaseParser","title":"<code>BaseParser</code>","text":"<p>This class is the base class for all parsers.  It contains the logic for calling and adding callbacks.</p> <p>A callback can be one of two different forms.  \"Notification callbacks\" are callbacks that are called when something happens - for example, when a new part of a multipart message is encountered by the parser.  \"Data callbacks\" are called when we get some sort of data - for example, part of the body of a multipart chunk.  Notification callbacks are called with no parameters, whereas data callbacks are called with three, as follows::</p> <pre><code>data_callback(data, start, end)\n</code></pre> <p>The \"data\" parameter is a bytestring (i.e. \"foo\" on Python 2, or b\"foo\" on Python 3).  \"start\" and \"end\" are integer indexes into the \"data\" string that represent the data of interest.  Thus, in a data callback, the slice <code>data[start:end]</code> represents the data that the callback is \"interested in\". The callback is not passed a copy of the data, since copying severely hurts performance.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>class BaseParser:\n    \"\"\"This class is the base class for all parsers.  It contains the logic for\n    calling and adding callbacks.\n\n    A callback can be one of two different forms.  \"Notification callbacks\" are\n    callbacks that are called when something happens - for example, when a new\n    part of a multipart message is encountered by the parser.  \"Data callbacks\"\n    are called when we get some sort of data - for example, part of the body of\n    a multipart chunk.  Notification callbacks are called with no parameters,\n    whereas data callbacks are called with three, as follows::\n\n        data_callback(data, start, end)\n\n    The \"data\" parameter is a bytestring (i.e. \"foo\" on Python 2, or b\"foo\" on\n    Python 3).  \"start\" and \"end\" are integer indexes into the \"data\" string\n    that represent the data of interest.  Thus, in a data callback, the slice\n    `data[start:end]` represents the data that the callback is \"interested in\".\n    The callback is not passed a copy of the data, since copying severely hurts\n    performance.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.logger = logging.getLogger(__name__)\n        self.callbacks: QuerystringCallbacks | OctetStreamCallbacks | MultipartCallbacks = {}\n\n    def callback(\n        self, name: CallbackName, data: bytes | None = None, start: int | None = None, end: int | None = None\n    ) -&gt; None:\n        \"\"\"This function calls a provided callback with some data.  If the\n        callback is not set, will do nothing.\n\n        Args:\n            name: The name of the callback to call (as a string).\n            data: Data to pass to the callback.  If None, then it is assumed that the callback is a notification\n                callback, and no parameters are given.\n            end: An integer that is passed to the data callback.\n            start: An integer that is passed to the data callback.\n        \"\"\"\n        on_name = \"on_\" + name\n        func = self.callbacks.get(on_name)\n        if func is None:\n            return\n        func = cast(\"Callable[..., Any]\", func)\n        # Depending on whether we're given a buffer...\n        if data is not None:\n            # Don't do anything if we have start == end.\n            if start is not None and start == end:\n                return\n\n            self.logger.debug(\"Calling %s with data[%d:%d]\", on_name, start, end)\n            func(data, start, end)\n        else:\n            self.logger.debug(\"Calling %s with no data\", on_name)\n            func()\n\n    def set_callback(self, name: CallbackName, new_func: Callable[..., Any] | None) -&gt; None:\n        \"\"\"Update the function for a callback.  Removes from the callbacks dict\n        if new_func is None.\n\n        :param name: The name of the callback to call (as a string).\n\n        :param new_func: The new function for the callback.  If None, then the\n                         callback will be removed (with no error if it does not\n                         exist).\n        \"\"\"\n        if new_func is None:\n            self.callbacks.pop(\"on_\" + name, None)  # type: ignore[misc]\n        else:\n            self.callbacks[\"on_\" + name] = new_func  # type: ignore[literal-required]\n\n    def close(self) -&gt; None:\n        pass  # pragma: no cover\n\n    def finalize(self) -&gt; None:\n        pass  # pragma: no cover\n\n    def __repr__(self) -&gt; str:\n        return \"%s()\" % self.__class__.__name__\n</code></pre>"},{"location":"api/#python_multipart.BaseParser-functions","title":"Functions","text":""},{"location":"api/#python_multipart.BaseParser.callback","title":"<code>callback(name, data=None, start=None, end=None)</code>","text":"<p>This function calls a provided callback with some data.  If the callback is not set, will do nothing.</p> <p>Args:     name: The name of the callback to call (as a string).     data: Data to pass to the callback.  If None, then it is assumed that the callback is a notification         callback, and no parameters are given.     end: An integer that is passed to the data callback.     start: An integer that is passed to the data callback.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def callback(\n    self, name: CallbackName, data: bytes | None = None, start: int | None = None, end: int | None = None\n) -&gt; None:\n    \"\"\"This function calls a provided callback with some data.  If the\n    callback is not set, will do nothing.\n\n    Args:\n        name: The name of the callback to call (as a string).\n        data: Data to pass to the callback.  If None, then it is assumed that the callback is a notification\n            callback, and no parameters are given.\n        end: An integer that is passed to the data callback.\n        start: An integer that is passed to the data callback.\n    \"\"\"\n    on_name = \"on_\" + name\n    func = self.callbacks.get(on_name)\n    if func is None:\n        return\n    func = cast(\"Callable[..., Any]\", func)\n    # Depending on whether we're given a buffer...\n    if data is not None:\n        # Don't do anything if we have start == end.\n        if start is not None and start == end:\n            return\n\n        self.logger.debug(\"Calling %s with data[%d:%d]\", on_name, start, end)\n        func(data, start, end)\n    else:\n        self.logger.debug(\"Calling %s with no data\", on_name)\n        func()\n</code></pre>"},{"location":"api/#python_multipart.BaseParser.set_callback","title":"<code>set_callback(name, new_func)</code>","text":"<p>Update the function for a callback.  Removes from the callbacks dict if new_func is None.</p> <p>Parameters:</p> Name Type Description Default <code>CallbackName</code> <p>The name of the callback to call (as a string).</p> required <code>Callable[..., Any] | None</code> <p>The new function for the callback.  If None, then the callback will be removed (with no error if it does not exist).</p> required Source code in <code>python_multipart/multipart.py</code> <pre><code>def set_callback(self, name: CallbackName, new_func: Callable[..., Any] | None) -&gt; None:\n    \"\"\"Update the function for a callback.  Removes from the callbacks dict\n    if new_func is None.\n\n    :param name: The name of the callback to call (as a string).\n\n    :param new_func: The new function for the callback.  If None, then the\n                     callback will be removed (with no error if it does not\n                     exist).\n    \"\"\"\n    if new_func is None:\n        self.callbacks.pop(\"on_\" + name, None)  # type: ignore[misc]\n    else:\n        self.callbacks[\"on_\" + name] = new_func  # type: ignore[literal-required]\n</code></pre>"},{"location":"api/#python_multipart.BaseParser.set_callback(name)","title":"<code>name</code>","text":""},{"location":"api/#python_multipart.BaseParser.set_callback(new_func)","title":"<code>new_func</code>","text":""},{"location":"api/#python_multipart.FormParser","title":"<code>FormParser</code>","text":"<p>This class is the all-in-one form parser.  Given all the information necessary to parse a form, it will instantiate the correct parser, create the proper :class:<code>Field</code> and :class:<code>File</code> classes to store the data that is parsed, and call the two given callbacks with each field and file as they become available.</p> <p>Args:     content_type: The Content-Type of the incoming request.  This is used to select the appropriate parser.     on_field: The callback to call when a field has been parsed and is ready for usage.  See above for parameters.     on_file: The callback to call when a file has been parsed and is ready for usage.  See above for parameters.     on_end: An optional callback to call when all fields and files in a request has been parsed.  Can be None.     boundary: If the request is a multipart/form-data request, this should be the boundary of the request, as given         in the Content-Type header, as a bytestring.     file_name: If the request is of type application/octet-stream, then the body of the request will not contain any         information about the uploaded file.  In such cases, you can provide the file name of the uploaded file         manually.     FileClass: The class to use for uploaded files.  Defaults to :class:<code>File</code>, but you can provide your own class         if you wish to customize behaviour.  The class will be instantiated as FileClass(file_name, field_name), and         it must provide the following functions::             - file_instance.write(data)             - file_instance.finalize()             - file_instance.close()     FieldClass: The class to use for uploaded fields.  Defaults to :class:<code>Field</code>, but you can provide your own         class if you wish to customize behaviour.  The class will be instantiated as FieldClass(field_name), and it         must provide the following functions::             - field_instance.write(data)             - field_instance.finalize()             - field_instance.close()             - field_instance.set_none()     config: Configuration to use for this FormParser.  The default values are taken from the DEFAULT_CONFIG value,         and then any keys present in this dictionary will overwrite the default values.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>class FormParser:\n    \"\"\"This class is the all-in-one form parser.  Given all the information\n    necessary to parse a form, it will instantiate the correct parser, create\n    the proper :class:`Field` and :class:`File` classes to store the data that\n    is parsed, and call the two given callbacks with each field and file as\n    they become available.\n\n    Args:\n        content_type: The Content-Type of the incoming request.  This is used to select the appropriate parser.\n        on_field: The callback to call when a field has been parsed and is ready for usage.  See above for parameters.\n        on_file: The callback to call when a file has been parsed and is ready for usage.  See above for parameters.\n        on_end: An optional callback to call when all fields and files in a request has been parsed.  Can be None.\n        boundary: If the request is a multipart/form-data request, this should be the boundary of the request, as given\n            in the Content-Type header, as a bytestring.\n        file_name: If the request is of type application/octet-stream, then the body of the request will not contain any\n            information about the uploaded file.  In such cases, you can provide the file name of the uploaded file\n            manually.\n        FileClass: The class to use for uploaded files.  Defaults to :class:`File`, but you can provide your own class\n            if you wish to customize behaviour.  The class will be instantiated as FileClass(file_name, field_name), and\n            it must provide the following functions::\n                - file_instance.write(data)\n                - file_instance.finalize()\n                - file_instance.close()\n        FieldClass: The class to use for uploaded fields.  Defaults to :class:`Field`, but you can provide your own\n            class if you wish to customize behaviour.  The class will be instantiated as FieldClass(field_name), and it\n            must provide the following functions::\n                - field_instance.write(data)\n                - field_instance.finalize()\n                - field_instance.close()\n                - field_instance.set_none()\n        config: Configuration to use for this FormParser.  The default values are taken from the DEFAULT_CONFIG value,\n            and then any keys present in this dictionary will overwrite the default values.\n    \"\"\"\n\n    #: This is the default configuration for our form parser.\n    #: Note: all file sizes should be in bytes.\n    DEFAULT_CONFIG: FormParserConfig = {\n        \"MAX_BODY_SIZE\": float(\"inf\"),\n        \"MAX_MEMORY_FILE_SIZE\": 1 * 1024 * 1024,\n        \"UPLOAD_DIR\": None,\n        \"UPLOAD_KEEP_FILENAME\": False,\n        \"UPLOAD_KEEP_EXTENSIONS\": False,\n        # Error on invalid Content-Transfer-Encoding?\n        \"UPLOAD_ERROR_ON_BAD_CTE\": False,\n    }\n\n    def __init__(\n        self,\n        content_type: str,\n        on_field: OnFieldCallback | None,\n        on_file: OnFileCallback | None,\n        on_end: Callable[[], None] | None = None,\n        boundary: bytes | str | None = None,\n        file_name: bytes | None = None,\n        FileClass: type[FileProtocol] = File,\n        FieldClass: type[FieldProtocol] = Field,\n        config: dict[Any, Any] = {},\n    ) -&gt; None:\n        self.logger = logging.getLogger(__name__)\n\n        # Save variables.\n        self.content_type = content_type\n        self.boundary = boundary\n        self.bytes_received = 0\n        self.parser = None\n\n        # Save callbacks.\n        self.on_field = on_field\n        self.on_file = on_file\n        self.on_end = on_end\n\n        # Save classes.\n        self.FileClass = File\n        self.FieldClass = Field\n\n        # Set configuration options.\n        self.config: FormParserConfig = self.DEFAULT_CONFIG.copy()\n        self.config.update(config)  # type: ignore[typeddict-item]\n\n        parser: OctetStreamParser | MultipartParser | QuerystringParser | None = None\n\n        # Depending on the Content-Type, we instantiate the correct parser.\n        if content_type == \"application/octet-stream\":\n            file: FileProtocol = None  # type: ignore\n\n            def on_start() -&gt; None:\n                nonlocal file\n                file = FileClass(file_name, None, config=cast(\"FileConfig\", self.config))\n\n            def on_data(data: bytes, start: int, end: int) -&gt; None:\n                nonlocal file\n                file.write(data[start:end])\n\n            def _on_end() -&gt; None:\n                nonlocal file\n                # Finalize the file itself.\n                file.finalize()\n\n                # Call our callback.\n                if on_file:\n                    on_file(file)\n\n                # Call the on-end callback.\n                if self.on_end is not None:\n                    self.on_end()\n\n            # Instantiate an octet-stream parser\n            parser = OctetStreamParser(\n                callbacks={\"on_start\": on_start, \"on_data\": on_data, \"on_end\": _on_end},\n                max_size=self.config[\"MAX_BODY_SIZE\"],\n            )\n\n        elif content_type == \"application/x-www-form-urlencoded\" or content_type == \"application/x-url-encoded\":\n            name_buffer: list[bytes] = []\n\n            f: FieldProtocol | None = None\n\n            def on_field_start() -&gt; None:\n                pass\n\n            def on_field_name(data: bytes, start: int, end: int) -&gt; None:\n                name_buffer.append(data[start:end])\n\n            def on_field_data(data: bytes, start: int, end: int) -&gt; None:\n                nonlocal f\n                if f is None:\n                    f = FieldClass(b\"\".join(name_buffer))\n                    del name_buffer[:]\n                f.write(data[start:end])\n\n            def on_field_end() -&gt; None:\n                nonlocal f\n                # Finalize and call callback.\n                if f is None:\n                    # If we get here, it's because there was no field data.\n                    # We create a field, set it to None, and then continue.\n                    f = FieldClass(b\"\".join(name_buffer))\n                    del name_buffer[:]\n                    f.set_none()\n\n                f.finalize()\n                if on_field:\n                    on_field(f)\n                f = None\n\n            def _on_end() -&gt; None:\n                if self.on_end is not None:\n                    self.on_end()\n\n            # Instantiate parser.\n            parser = QuerystringParser(\n                callbacks={\n                    \"on_field_start\": on_field_start,\n                    \"on_field_name\": on_field_name,\n                    \"on_field_data\": on_field_data,\n                    \"on_field_end\": on_field_end,\n                    \"on_end\": _on_end,\n                },\n                max_size=self.config[\"MAX_BODY_SIZE\"],\n            )\n\n        elif content_type == \"multipart/form-data\":\n            if boundary is None:\n                self.logger.error(\"No boundary given\")\n                raise FormParserError(\"No boundary given\")\n\n            header_name: list[bytes] = []\n            header_value: list[bytes] = []\n            headers: dict[bytes, bytes] = {}\n\n            f_multi: FileProtocol | FieldProtocol | None = None\n            writer = None\n            is_file = False\n\n            def on_part_begin() -&gt; None:\n                # Reset headers in case this isn't the first part.\n                nonlocal headers\n                headers = {}\n\n            def on_part_data(data: bytes, start: int, end: int) -&gt; None:\n                nonlocal writer\n                assert writer is not None\n                writer.write(data[start:end])\n                # TODO: check for error here.\n\n            def on_part_end() -&gt; None:\n                nonlocal f_multi, is_file\n                assert f_multi is not None\n                f_multi.finalize()\n                if is_file:\n                    if on_file:\n                        on_file(f_multi)\n                else:\n                    if on_field:\n                        on_field(cast(\"FieldProtocol\", f_multi))\n\n            def on_header_field(data: bytes, start: int, end: int) -&gt; None:\n                header_name.append(data[start:end])\n\n            def on_header_value(data: bytes, start: int, end: int) -&gt; None:\n                header_value.append(data[start:end])\n\n            def on_header_end() -&gt; None:\n                headers[b\"\".join(header_name)] = b\"\".join(header_value)\n                del header_name[:]\n                del header_value[:]\n\n            def on_headers_finished() -&gt; None:\n                nonlocal is_file, f_multi, writer\n                # Reset the 'is file' flag.\n                is_file = False\n\n                # Parse the content-disposition header.\n                # TODO: handle mixed case\n                content_disp = headers.get(b\"Content-Disposition\")\n                disp, options = parse_options_header(content_disp)\n\n                # Get the field and filename.\n                field_name = options.get(b\"name\")\n                file_name = options.get(b\"filename\")\n                # TODO: check for errors\n\n                # Create the proper class.\n                if file_name is None:\n                    f_multi = FieldClass(field_name)\n                else:\n                    f_multi = FileClass(file_name, field_name, config=cast(\"FileConfig\", self.config))\n                    is_file = True\n\n                # Parse the given Content-Transfer-Encoding to determine what\n                # we need to do with the incoming data.\n                # TODO: check that we properly handle 8bit / 7bit encoding.\n                transfer_encoding = headers.get(b\"Content-Transfer-Encoding\", b\"7bit\")\n\n                if transfer_encoding in (b\"binary\", b\"8bit\", b\"7bit\"):\n                    writer = f_multi\n\n                elif transfer_encoding == b\"base64\":\n                    writer = Base64Decoder(f_multi)\n\n                elif transfer_encoding == b\"quoted-printable\":\n                    writer = QuotedPrintableDecoder(f_multi)\n\n                else:\n                    self.logger.warning(\"Unknown Content-Transfer-Encoding: %r\", transfer_encoding)\n                    if self.config[\"UPLOAD_ERROR_ON_BAD_CTE\"]:\n                        raise FormParserError(f'Unknown Content-Transfer-Encoding \"{transfer_encoding!r}\"')\n                    else:\n                        # If we aren't erroring, then we just treat this as an\n                        # unencoded Content-Transfer-Encoding.\n                        writer = f_multi\n\n            def _on_end() -&gt; None:\n                nonlocal writer\n                if writer is not None:\n                    writer.finalize()\n                if self.on_end is not None:\n                    self.on_end()\n\n            # Instantiate a multipart parser.\n            parser = MultipartParser(\n                boundary,\n                callbacks={\n                    \"on_part_begin\": on_part_begin,\n                    \"on_part_data\": on_part_data,\n                    \"on_part_end\": on_part_end,\n                    \"on_header_field\": on_header_field,\n                    \"on_header_value\": on_header_value,\n                    \"on_header_end\": on_header_end,\n                    \"on_headers_finished\": on_headers_finished,\n                    \"on_end\": _on_end,\n                },\n                max_size=self.config[\"MAX_BODY_SIZE\"],\n            )\n\n        else:\n            self.logger.warning(\"Unknown Content-Type: %r\", content_type)\n            raise FormParserError(f\"Unknown Content-Type: {content_type}\")\n\n        self.parser = parser\n\n    def write(self, data: bytes) -&gt; int:\n        \"\"\"Write some data.  The parser will forward this to the appropriate\n        underlying parser.\n\n        Args:\n            data: The data to write.\n\n        Returns:\n            The number of bytes processed.\n        \"\"\"\n        self.bytes_received += len(data)\n        # TODO: check the parser's return value for errors?\n        assert self.parser is not None\n        return self.parser.write(data)\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize the parser.\"\"\"\n        if self.parser is not None and hasattr(self.parser, \"finalize\"):\n            self.parser.finalize()\n\n    def close(self) -&gt; None:\n        \"\"\"Close the parser.\"\"\"\n        if self.parser is not None and hasattr(self.parser, \"close\"):\n            self.parser.close()\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(content_type={self.content_type!r}, parser={self.parser!r})\"\n</code></pre>"},{"location":"api/#python_multipart.FormParser-functions","title":"Functions","text":""},{"location":"api/#python_multipart.FormParser.close","title":"<code>close()</code>","text":"<p>Close the parser.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the parser.\"\"\"\n    if self.parser is not None and hasattr(self.parser, \"close\"):\n        self.parser.close()\n</code></pre>"},{"location":"api/#python_multipart.FormParser.finalize","title":"<code>finalize()</code>","text":"<p>Finalize the parser.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize the parser.\"\"\"\n    if self.parser is not None and hasattr(self.parser, \"finalize\"):\n        self.parser.finalize()\n</code></pre>"},{"location":"api/#python_multipart.FormParser.write","title":"<code>write(data)</code>","text":"<p>Write some data.  The parser will forward this to the appropriate underlying parser.</p> <p>Args:     data: The data to write.</p> <p>Returns:     The number of bytes processed.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def write(self, data: bytes) -&gt; int:\n    \"\"\"Write some data.  The parser will forward this to the appropriate\n    underlying parser.\n\n    Args:\n        data: The data to write.\n\n    Returns:\n        The number of bytes processed.\n    \"\"\"\n    self.bytes_received += len(data)\n    # TODO: check the parser's return value for errors?\n    assert self.parser is not None\n    return self.parser.write(data)\n</code></pre>"},{"location":"api/#python_multipart.MultipartParser","title":"<code>MultipartParser</code>","text":"<p>               Bases: <code>BaseParser</code></p> <p>This class is a streaming multipart/form-data parser.</p> Callback Name Parameters Description on_part_begin None Called when a new part of the multipart message is encountered. on_part_data data, start, end Called when a portion of a part's data is encountered. on_part_end None Called when the end of a part is reached. on_header_begin None Called when we've found a new header in a part of a multipart message on_header_field data, start, end Called each time an additional portion of a header is read (i.e. the part of the header that is before the colon; the \"Foo\" in \"Foo: Bar\"). on_header_value data, start, end Called when we get data for a header. on_header_end None Called when the current header is finished - i.e. we've reached the newline at the end of the header. on_headers_finished None Called when all headers are finished, and before the part data starts. on_end None Called when the parser is finished parsing all data. <p>Args:     boundary: The multipart boundary.  This is required, and must match what is given in the HTTP request - usually in the Content-Type header.     callbacks: A dictionary of callbacks.  See the documentation for <code>BaseParser</code>.     max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>class MultipartParser(BaseParser):\n    \"\"\"This class is a streaming multipart/form-data parser.\n\n    | Callback Name      | Parameters      | Description |\n    |--------------------|-----------------|-------------|\n    | on_part_begin      | None            | Called when a new part of the multipart message is encountered. |\n    | on_part_data       | data, start, end| Called when a portion of a part's data is encountered. |\n    | on_part_end        | None            | Called when the end of a part is reached. |\n    | on_header_begin    | None            | Called when we've found a new header in a part of a multipart message |\n    | on_header_field    | data, start, end| Called each time an additional portion of a header is read (i.e. the part of the header that is before the colon; the \"Foo\" in \"Foo: Bar\"). |\n    | on_header_value    | data, start, end| Called when we get data for a header. |\n    | on_header_end      | None            | Called when the current header is finished - i.e. we've reached the newline at the end of the header. |\n    | on_headers_finished| None            | Called when all headers are finished, and before the part data starts. |\n    | on_end             | None            | Called when the parser is finished parsing all data. |\n\n    Args:\n        boundary: The multipart boundary.  This is required, and must match what is given in the HTTP request - usually in the Content-Type header.\n        callbacks: A dictionary of callbacks.  See the documentation for [`BaseParser`][python_multipart.BaseParser].\n        max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self, boundary: bytes | str, callbacks: MultipartCallbacks = {}, max_size: float = float(\"inf\")\n    ) -&gt; None:\n        # Initialize parser state.\n        super().__init__()\n        self.state = MultipartState.START\n        self.index = self.flags = 0\n\n        self.callbacks = callbacks\n\n        if not isinstance(max_size, Number) or max_size &lt; 1:\n            raise ValueError(\"max_size must be a positive number, not %r\" % max_size)\n        self.max_size = max_size\n        self._current_size = 0\n\n        # Setup marks.  These are used to track the state of data received.\n        self.marks: dict[str, int] = {}\n\n        # Save our boundary.\n        if isinstance(boundary, str):  # pragma: no cover\n            boundary = boundary.encode(\"latin-1\")\n        self.boundary = b\"\\r\\n--\" + boundary\n\n    def write(self, data: bytes) -&gt; int:\n        \"\"\"Write some data to the parser, which will perform size verification,\n        and then parse the data into the appropriate location (e.g. header,\n        data, etc.), and pass this on to the underlying callback.  If an error\n        is encountered, a MultipartParseError will be raised.  The \"offset\"\n        attribute on the raised exception will be set to the offset of the byte\n        in the input chunk that caused the error.\n\n        Args:\n            data: The data to write to the parser.\n\n        Returns:\n            The number of bytes written.\n        \"\"\"\n        # Handle sizing.\n        data_len = len(data)\n        if (self._current_size + data_len) &gt; self.max_size:\n            # We truncate the length of data that we are to process.\n            new_size = int(self.max_size - self._current_size)\n            self.logger.warning(\n                \"Current size is %d (max %d), so truncating data length from %d to %d\",\n                self._current_size,\n                self.max_size,\n                data_len,\n                new_size,\n            )\n            data_len = new_size\n\n        l = 0\n        try:\n            l = self._internal_write(data, data_len)\n        finally:\n            self._current_size += l\n\n        return l\n\n    def _internal_write(self, data: bytes, length: int) -&gt; int:\n        # Get values from locals.\n        boundary = self.boundary\n\n        # Get our state, flags and index.  These are persisted between calls to\n        # this function.\n        state = self.state\n        index = self.index\n        flags = self.flags\n\n        # Our index defaults to 0.\n        i = 0\n\n        # Set a mark.\n        def set_mark(name: str) -&gt; None:\n            self.marks[name] = i\n\n        # Remove a mark.\n        def delete_mark(name: str, reset: bool = False) -&gt; None:\n            self.marks.pop(name, None)\n\n        # Helper function that makes calling a callback with data easier. The\n        # 'remaining' parameter will callback from the marked value until the\n        # end of the buffer, and reset the mark, instead of deleting it.  This\n        # is used at the end of the function to call our callbacks with any\n        # remaining data in this chunk.\n        def data_callback(name: CallbackName, end_i: int, remaining: bool = False) -&gt; None:\n            marked_index = self.marks.get(name)\n            if marked_index is None:\n                return\n\n            # Otherwise, we call it from the mark to the current byte we're\n            # processing.\n            if end_i &lt;= marked_index:\n                # There is no additional data to send.\n                pass\n            elif marked_index &gt;= 0:\n                # We are emitting data from the local buffer.\n                self.callback(name, data, marked_index, end_i)\n            else:\n                # Some of the data comes from a partial boundary match.\n                # and requires look-behind.\n                # We need to use self.flags (and not flags) because we care about\n                # the state when we entered the loop.\n                lookbehind_len = -marked_index\n                if lookbehind_len &lt;= len(boundary):\n                    self.callback(name, boundary, 0, lookbehind_len)\n                elif self.flags &amp; FLAG_PART_BOUNDARY:\n                    lookback = boundary + b\"\\r\\n\"\n                    self.callback(name, lookback, 0, lookbehind_len)\n                elif self.flags &amp; FLAG_LAST_BOUNDARY:\n                    lookback = boundary + b\"--\\r\\n\"\n                    self.callback(name, lookback, 0, lookbehind_len)\n                else:  # pragma: no cover (error case)\n                    self.logger.warning(\"Look-back buffer error\")\n\n                if end_i &gt; 0:\n                    self.callback(name, data, 0, end_i)\n            # If we're getting remaining data, we have got all the data we\n            # can be certain is not a boundary, leaving only a partial boundary match.\n            if remaining:\n                self.marks[name] = end_i - length\n            else:\n                self.marks.pop(name, None)\n\n        # For each byte...\n        while i &lt; length:\n            c = data[i]\n\n            if state == MultipartState.START:\n                # Skip leading newlines\n                if c == CR or c == LF:\n                    i += 1\n                    continue\n\n                # index is used as in index into our boundary.  Set to 0.\n                index = 0\n\n                # Move to the next state, but decrement i so that we re-process\n                # this character.\n                state = MultipartState.START_BOUNDARY\n                i -= 1\n\n            elif state == MultipartState.START_BOUNDARY:\n                # Check to ensure that the last 2 characters in our boundary\n                # are CRLF.\n                if index == len(boundary) - 2:\n                    if c == HYPHEN:\n                        # Potential empty message.\n                        state = MultipartState.END_BOUNDARY\n                    elif c != CR:\n                        # Error!\n                        msg = \"Did not find CR at end of boundary (%d)\" % (i,)\n                        self.logger.warning(msg)\n                        e = MultipartParseError(msg)\n                        e.offset = i\n                        raise e\n\n                    index += 1\n\n                elif index == len(boundary) - 2 + 1:\n                    if c != LF:\n                        msg = \"Did not find LF at end of boundary (%d)\" % (i,)\n                        self.logger.warning(msg)\n                        e = MultipartParseError(msg)\n                        e.offset = i\n                        raise e\n\n                    # The index is now used for indexing into our boundary.\n                    index = 0\n\n                    # Callback for the start of a part.\n                    self.callback(\"part_begin\")\n\n                    # Move to the next character and state.\n                    state = MultipartState.HEADER_FIELD_START\n\n                else:\n                    # Check to ensure our boundary matches\n                    if c != boundary[index + 2]:\n                        msg = \"Expected boundary character %r, got %r at index %d\" % (boundary[index + 2], c, index + 2)\n                        self.logger.warning(msg)\n                        e = MultipartParseError(msg)\n                        e.offset = i\n                        raise e\n\n                    # Increment index into boundary and continue.\n                    index += 1\n\n            elif state == MultipartState.HEADER_FIELD_START:\n                # Mark the start of a header field here, reset the index, and\n                # continue parsing our header field.\n                index = 0\n\n                # Set a mark of our header field.\n                set_mark(\"header_field\")\n\n                # Notify that we're starting a header if the next character is\n                # not a CR; a CR at the beginning of the header will cause us\n                # to stop parsing headers in the MultipartState.HEADER_FIELD state,\n                # below.\n                if c != CR:\n                    self.callback(\"header_begin\")\n\n                # Move to parsing header fields.\n                state = MultipartState.HEADER_FIELD\n                i -= 1\n\n            elif state == MultipartState.HEADER_FIELD:\n                # If we've reached a CR at the beginning of a header, it means\n                # that we've reached the second of 2 newlines, and so there are\n                # no more headers to parse.\n                if c == CR and index == 0:\n                    delete_mark(\"header_field\")\n                    state = MultipartState.HEADERS_ALMOST_DONE\n                    i += 1\n                    continue\n\n                # Increment our index in the header.\n                index += 1\n\n                # If we've reached a colon, we're done with this header.\n                if c == COLON:\n                    # A 0-length header is an error.\n                    if index == 1:\n                        msg = \"Found 0-length header at %d\" % (i,)\n                        self.logger.warning(msg)\n                        e = MultipartParseError(msg)\n                        e.offset = i\n                        raise e\n\n                    # Call our callback with the header field.\n                    data_callback(\"header_field\", i)\n\n                    # Move to parsing the header value.\n                    state = MultipartState.HEADER_VALUE_START\n\n                elif c not in TOKEN_CHARS_SET:\n                    msg = \"Found invalid character %r in header at %d\" % (c, i)\n                    self.logger.warning(msg)\n                    e = MultipartParseError(msg)\n                    e.offset = i\n                    raise e\n\n            elif state == MultipartState.HEADER_VALUE_START:\n                # Skip leading spaces.\n                if c == SPACE:\n                    i += 1\n                    continue\n\n                # Mark the start of the header value.\n                set_mark(\"header_value\")\n\n                # Move to the header-value state, reprocessing this character.\n                state = MultipartState.HEADER_VALUE\n                i -= 1\n\n            elif state == MultipartState.HEADER_VALUE:\n                # If we've got a CR, we're nearly done our headers.  Otherwise,\n                # we do nothing and just move past this character.\n                if c == CR:\n                    data_callback(\"header_value\", i)\n                    self.callback(\"header_end\")\n                    state = MultipartState.HEADER_VALUE_ALMOST_DONE\n\n            elif state == MultipartState.HEADER_VALUE_ALMOST_DONE:\n                # The last character should be a LF.  If not, it's an error.\n                if c != LF:\n                    msg = f\"Did not find LF character at end of header (found {c!r})\"\n                    self.logger.warning(msg)\n                    e = MultipartParseError(msg)\n                    e.offset = i\n                    raise e\n\n                # Move back to the start of another header.  Note that if that\n                # state detects ANOTHER newline, it'll trigger the end of our\n                # headers.\n                state = MultipartState.HEADER_FIELD_START\n\n            elif state == MultipartState.HEADERS_ALMOST_DONE:\n                # We're almost done our headers.  This is reached when we parse\n                # a CR at the beginning of a header, so our next character\n                # should be a LF, or it's an error.\n                if c != LF:\n                    msg = f\"Did not find LF at end of headers (found {c!r})\"\n                    self.logger.warning(msg)\n                    e = MultipartParseError(msg)\n                    e.offset = i\n                    raise e\n\n                self.callback(\"headers_finished\")\n                state = MultipartState.PART_DATA_START\n\n            elif state == MultipartState.PART_DATA_START:\n                # Mark the start of our part data.\n                set_mark(\"part_data\")\n\n                # Start processing part data, including this character.\n                state = MultipartState.PART_DATA\n                i -= 1\n\n            elif state == MultipartState.PART_DATA:\n                # We're processing our part data right now.  During this, we\n                # need to efficiently search for our boundary, since any data\n                # on any number of lines can be a part of the current data.\n\n                # Save the current value of our index.  We use this in case we\n                # find part of a boundary, but it doesn't match fully.\n                prev_index = index\n\n                # Set up variables.\n                boundary_length = len(boundary)\n                data_length = length\n\n                # If our index is 0, we're starting a new part, so start our\n                # search.\n                if index == 0:\n                    # The most common case is likely to be that the whole\n                    # boundary is present in the buffer.\n                    # Calling `find` is much faster than iterating here.\n                    i0 = data.find(boundary, i, data_length)\n                    if i0 &gt;= 0:\n                        # We matched the whole boundary string.\n                        index = boundary_length - 1\n                        i = i0 + boundary_length - 1\n                    else:\n                        # No match found for whole string.\n                        # There may be a partial boundary at the end of the\n                        # data, which the find will not match.\n                        # Since the length should to be searched is limited to\n                        # the boundary length, just perform a naive search.\n                        i = max(i, data_length - boundary_length)\n\n                        # Search forward until we either hit the end of our buffer,\n                        # or reach a potential start of the boundary.\n                        while i &lt; data_length - 1 and data[i] != boundary[0]:\n                            i += 1\n\n                    c = data[i]\n\n                # Now, we have a couple of cases here.  If our index is before\n                # the end of the boundary...\n                if index &lt; boundary_length:\n                    # If the character matches...\n                    if boundary[index] == c:\n                        # The current character matches, so continue!\n                        index += 1\n                    else:\n                        index = 0\n\n                # Our index is equal to the length of our boundary!\n                elif index == boundary_length:\n                    # First we increment it.\n                    index += 1\n\n                    # Now, if we've reached a newline, we need to set this as\n                    # the potential end of our boundary.\n                    if c == CR:\n                        flags |= FLAG_PART_BOUNDARY\n\n                    # Otherwise, if this is a hyphen, we might be at the last\n                    # of all boundaries.\n                    elif c == HYPHEN:\n                        flags |= FLAG_LAST_BOUNDARY\n\n                    # Otherwise, we reset our index, since this isn't either a\n                    # newline or a hyphen.\n                    else:\n                        index = 0\n\n                # Our index is right after the part boundary, which should be\n                # a LF.\n                elif index == boundary_length + 1:\n                    # If we're at a part boundary (i.e. we've seen a CR\n                    # character already)...\n                    if flags &amp; FLAG_PART_BOUNDARY:\n                        # We need a LF character next.\n                        if c == LF:\n                            # Unset the part boundary flag.\n                            flags &amp;= ~FLAG_PART_BOUNDARY\n\n                            # We have identified a boundary, callback for any data before it.\n                            data_callback(\"part_data\", i - index)\n                            # Callback indicating that we've reached the end of\n                            # a part, and are starting a new one.\n                            self.callback(\"part_end\")\n                            self.callback(\"part_begin\")\n\n                            # Move to parsing new headers.\n                            index = 0\n                            state = MultipartState.HEADER_FIELD_START\n                            i += 1\n                            continue\n\n                        # We didn't find an LF character, so no match.  Reset\n                        # our index and clear our flag.\n                        index = 0\n                        flags &amp;= ~FLAG_PART_BOUNDARY\n\n                    # Otherwise, if we're at the last boundary (i.e. we've\n                    # seen a hyphen already)...\n                    elif flags &amp; FLAG_LAST_BOUNDARY:\n                        # We need a second hyphen here.\n                        if c == HYPHEN:\n                            # We have identified a boundary, callback for any data before it.\n                            data_callback(\"part_data\", i - index)\n                            # Callback to end the current part, and then the\n                            # message.\n                            self.callback(\"part_end\")\n                            self.callback(\"end\")\n                            state = MultipartState.END\n                        else:\n                            # No match, so reset index.\n                            index = 0\n\n                # Otherwise, our index is 0.  If the previous index is not, it\n                # means we reset something, and we need to take the data we\n                # thought was part of our boundary and send it along as actual\n                # data.\n                if index == 0 and prev_index &gt; 0:\n                    # Overwrite our previous index.\n                    prev_index = 0\n\n                    # Re-consider the current character, since this could be\n                    # the start of the boundary itself.\n                    i -= 1\n\n            elif state == MultipartState.END_BOUNDARY:\n                if index == len(boundary) - 2 + 1:\n                    if c != HYPHEN:\n                        msg = \"Did not find - at end of boundary (%d)\" % (i,)\n                        self.logger.warning(msg)\n                        e = MultipartParseError(msg)\n                        e.offset = i\n                        raise e\n                    index += 1\n                    self.callback(\"end\")\n                    state = MultipartState.END\n\n            elif state == MultipartState.END:\n                # Don't do anything if chunk ends with CRLF.\n                if c == CR and i + 1 &lt; length and data[i + 1] == LF:\n                    i += 2\n                    continue\n                # Skip data after the last boundary.\n                self.logger.warning(\"Skipping data after last boundary\")\n                i = length\n                break\n\n            else:  # pragma: no cover (error case)\n                # We got into a strange state somehow!  Just stop processing.\n                msg = \"Reached an unknown state %d at %d\" % (state, i)\n                self.logger.warning(msg)\n                e = MultipartParseError(msg)\n                e.offset = i\n                raise e\n\n            # Move to the next byte.\n            i += 1\n\n        # We call our callbacks with any remaining data.  Note that we pass\n        # the 'remaining' flag, which sets the mark back to 0 instead of\n        # deleting it, if it's found.  This is because, if the mark is found\n        # at this point, we assume that there's data for one of these things\n        # that has been parsed, but not yet emitted.  And, as such, it implies\n        # that we haven't yet reached the end of this 'thing'.  So, by setting\n        # the mark to 0, we cause any data callbacks that take place in future\n        # calls to this function to start from the beginning of that buffer.\n        data_callback(\"header_field\", length, True)\n        data_callback(\"header_value\", length, True)\n        data_callback(\"part_data\", length - index, True)\n\n        # Save values to locals.\n        self.state = state\n        self.index = index\n        self.flags = flags\n\n        # Return our data length to indicate no errors, and that we processed\n        # all of it.\n        return length\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize this parser, which signals to that we are finished parsing.\n\n        Note: It does not currently, but in the future, it will verify that we\n        are in the final state of the parser (i.e. the end of the multipart\n        message is well-formed), and, if not, throw an error.\n        \"\"\"\n        # TODO: verify that we're in the state MultipartState.END, otherwise throw an\n        # error or otherwise state that we're not finished parsing.\n        pass\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(boundary={self.boundary!r})\"\n</code></pre>"},{"location":"api/#python_multipart.MultipartParser-functions","title":"Functions","text":""},{"location":"api/#python_multipart.MultipartParser.finalize","title":"<code>finalize()</code>","text":"<p>Finalize this parser, which signals to that we are finished parsing.</p> <p>Note: It does not currently, but in the future, it will verify that we are in the final state of the parser (i.e. the end of the multipart message is well-formed), and, if not, throw an error.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize this parser, which signals to that we are finished parsing.\n\n    Note: It does not currently, but in the future, it will verify that we\n    are in the final state of the parser (i.e. the end of the multipart\n    message is well-formed), and, if not, throw an error.\n    \"\"\"\n    # TODO: verify that we're in the state MultipartState.END, otherwise throw an\n    # error or otherwise state that we're not finished parsing.\n    pass\n</code></pre>"},{"location":"api/#python_multipart.MultipartParser.write","title":"<code>write(data)</code>","text":"<p>Write some data to the parser, which will perform size verification, and then parse the data into the appropriate location (e.g. header, data, etc.), and pass this on to the underlying callback.  If an error is encountered, a MultipartParseError will be raised.  The \"offset\" attribute on the raised exception will be set to the offset of the byte in the input chunk that caused the error.</p> <p>Args:     data: The data to write to the parser.</p> <p>Returns:     The number of bytes written.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def write(self, data: bytes) -&gt; int:\n    \"\"\"Write some data to the parser, which will perform size verification,\n    and then parse the data into the appropriate location (e.g. header,\n    data, etc.), and pass this on to the underlying callback.  If an error\n    is encountered, a MultipartParseError will be raised.  The \"offset\"\n    attribute on the raised exception will be set to the offset of the byte\n    in the input chunk that caused the error.\n\n    Args:\n        data: The data to write to the parser.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    # Handle sizing.\n    data_len = len(data)\n    if (self._current_size + data_len) &gt; self.max_size:\n        # We truncate the length of data that we are to process.\n        new_size = int(self.max_size - self._current_size)\n        self.logger.warning(\n            \"Current size is %d (max %d), so truncating data length from %d to %d\",\n            self._current_size,\n            self.max_size,\n            data_len,\n            new_size,\n        )\n        data_len = new_size\n\n    l = 0\n    try:\n        l = self._internal_write(data, data_len)\n    finally:\n        self._current_size += l\n\n    return l\n</code></pre>"},{"location":"api/#python_multipart.OctetStreamParser","title":"<code>OctetStreamParser</code>","text":"<p>               Bases: <code>BaseParser</code></p> <p>This parser parses an octet-stream request body and calls callbacks when incoming data is received.  Callbacks are as follows:</p> Callback Name Parameters Description on_start None Called when the first data is parsed. on_data data, start, end Called for each data chunk that is parsed. on_end None Called when the parser is finished parsing all data. <p>Args:     callbacks: A dictionary of callbacks.  See the documentation for <code>BaseParser</code>.     max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>class OctetStreamParser(BaseParser):\n    \"\"\"This parser parses an octet-stream request body and calls callbacks when\n    incoming data is received.  Callbacks are as follows:\n\n    | Callback Name  | Parameters      | Description                                         |\n    |----------------|-----------------|-----------------------------------------------------|\n    | on_start       | None            | Called when the first data is parsed.               |\n    | on_data        | data, start, end| Called for each data chunk that is parsed.           |\n    | on_end         | None            | Called when the parser is finished parsing all data.|\n\n    Args:\n        callbacks: A dictionary of callbacks.  See the documentation for [`BaseParser`][python_multipart.BaseParser].\n        max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.\n    \"\"\"\n\n    def __init__(self, callbacks: OctetStreamCallbacks = {}, max_size: float = float(\"inf\")):\n        super().__init__()\n        self.callbacks = callbacks\n        self._started = False\n\n        if not isinstance(max_size, Number) or max_size &lt; 1:\n            raise ValueError(\"max_size must be a positive number, not %r\" % max_size)\n        self.max_size: int | float = max_size\n        self._current_size = 0\n\n    def write(self, data: bytes) -&gt; int:\n        \"\"\"Write some data to the parser, which will perform size verification,\n        and then pass the data to the underlying callback.\n\n        Args:\n            data: The data to write to the parser.\n\n        Returns:\n            The number of bytes written.\n        \"\"\"\n        if not self._started:\n            self.callback(\"start\")\n            self._started = True\n\n        # Truncate data length.\n        data_len = len(data)\n        if (self._current_size + data_len) &gt; self.max_size:\n            # We truncate the length of data that we are to process.\n            new_size = int(self.max_size - self._current_size)\n            self.logger.warning(\n                \"Current size is %d (max %d), so truncating data length from %d to %d\",\n                self._current_size,\n                self.max_size,\n                data_len,\n                new_size,\n            )\n            data_len = new_size\n\n        # Increment size, then callback, in case there's an exception.\n        self._current_size += data_len\n        self.callback(\"data\", data, 0, data_len)\n        return data_len\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize this parser, which signals to that we are finished parsing,\n        and sends the on_end callback.\n        \"\"\"\n        self.callback(\"end\")\n\n    def __repr__(self) -&gt; str:\n        return \"%s()\" % self.__class__.__name__\n</code></pre>"},{"location":"api/#python_multipart.OctetStreamParser-functions","title":"Functions","text":""},{"location":"api/#python_multipart.OctetStreamParser.finalize","title":"<code>finalize()</code>","text":"<p>Finalize this parser, which signals to that we are finished parsing, and sends the on_end callback.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize this parser, which signals to that we are finished parsing,\n    and sends the on_end callback.\n    \"\"\"\n    self.callback(\"end\")\n</code></pre>"},{"location":"api/#python_multipart.OctetStreamParser.write","title":"<code>write(data)</code>","text":"<p>Write some data to the parser, which will perform size verification, and then pass the data to the underlying callback.</p> <p>Args:     data: The data to write to the parser.</p> <p>Returns:     The number of bytes written.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def write(self, data: bytes) -&gt; int:\n    \"\"\"Write some data to the parser, which will perform size verification,\n    and then pass the data to the underlying callback.\n\n    Args:\n        data: The data to write to the parser.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not self._started:\n        self.callback(\"start\")\n        self._started = True\n\n    # Truncate data length.\n    data_len = len(data)\n    if (self._current_size + data_len) &gt; self.max_size:\n        # We truncate the length of data that we are to process.\n        new_size = int(self.max_size - self._current_size)\n        self.logger.warning(\n            \"Current size is %d (max %d), so truncating data length from %d to %d\",\n            self._current_size,\n            self.max_size,\n            data_len,\n            new_size,\n        )\n        data_len = new_size\n\n    # Increment size, then callback, in case there's an exception.\n    self._current_size += data_len\n    self.callback(\"data\", data, 0, data_len)\n    return data_len\n</code></pre>"},{"location":"api/#python_multipart.QuerystringParser","title":"<code>QuerystringParser</code>","text":"<p>               Bases: <code>BaseParser</code></p> <p>This is a streaming querystring parser.  It will consume data, and call the callbacks given when it has data.</p> Callback Name Parameters Description on_field_start None Called when a new field is encountered. on_field_name data, start, end Called when a portion of a field's name is encountered. on_field_data data, start, end Called when a portion of a field's data is encountered. on_field_end None Called when the end of a field is encountered. on_end None Called when the parser is finished parsing all data. <p>Args:     callbacks: A dictionary of callbacks.  See the documentation for <code>BaseParser</code>.     strict_parsing: Whether or not to parse the body strictly.  Defaults to False.  If this is set to True, then the         behavior of the parser changes as the following: if a field has a value with an equal sign         (e.g. \"foo=bar\", or \"foo=\"), it is always included.  If a field has no equals sign (e.g. \"...&amp;name&amp;...\"),         it will be treated as an error if 'strict_parsing' is True, otherwise included.  If an error is encountered,         then a <code>QuerystringParseError</code> will be raised.     max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>class QuerystringParser(BaseParser):\n    \"\"\"This is a streaming querystring parser.  It will consume data, and call\n    the callbacks given when it has data.\n\n    | Callback Name  | Parameters      | Description                                         |\n    |----------------|-----------------|-----------------------------------------------------|\n    | on_field_start | None            | Called when a new field is encountered.             |\n    | on_field_name  | data, start, end| Called when a portion of a field's name is encountered. |\n    | on_field_data  | data, start, end| Called when a portion of a field's data is encountered. |\n    | on_field_end   | None            | Called when the end of a field is encountered.      |\n    | on_end         | None            | Called when the parser is finished parsing all data.|\n\n    Args:\n        callbacks: A dictionary of callbacks.  See the documentation for [`BaseParser`][python_multipart.BaseParser].\n        strict_parsing: Whether or not to parse the body strictly.  Defaults to False.  If this is set to True, then the\n            behavior of the parser changes as the following: if a field has a value with an equal sign\n            (e.g. \"foo=bar\", or \"foo=\"), it is always included.  If a field has no equals sign (e.g. \"...&amp;name&amp;...\"),\n            it will be treated as an error if 'strict_parsing' is True, otherwise included.  If an error is encountered,\n            then a [`QuerystringParseError`][python_multipart.exceptions.QuerystringParseError] will be raised.\n        max_size: The maximum size of body to parse.  Defaults to infinity - i.e. unbounded.\n    \"\"\"  # noqa: E501\n\n    state: QuerystringState\n\n    def __init__(\n        self, callbacks: QuerystringCallbacks = {}, strict_parsing: bool = False, max_size: float = float(\"inf\")\n    ) -&gt; None:\n        super().__init__()\n        self.state = QuerystringState.BEFORE_FIELD\n        self._found_sep = False\n\n        self.callbacks = callbacks\n\n        # Max-size stuff\n        if not isinstance(max_size, Number) or max_size &lt; 1:\n            raise ValueError(\"max_size must be a positive number, not %r\" % max_size)\n        self.max_size: int | float = max_size\n        self._current_size = 0\n\n        # Should parsing be strict?\n        self.strict_parsing = strict_parsing\n\n    def write(self, data: bytes) -&gt; int:\n        \"\"\"Write some data to the parser, which will perform size verification,\n        parse into either a field name or value, and then pass the\n        corresponding data to the underlying callback.  If an error is\n        encountered while parsing, a QuerystringParseError will be raised.  The\n        \"offset\" attribute of the raised exception will be set to the offset in\n        the input data chunk (NOT the overall stream) that caused the error.\n\n        Args:\n            data: The data to write to the parser.\n\n        Returns:\n            The number of bytes written.\n        \"\"\"\n        # Handle sizing.\n        data_len = len(data)\n        if (self._current_size + data_len) &gt; self.max_size:\n            # We truncate the length of data that we are to process.\n            new_size = int(self.max_size - self._current_size)\n            self.logger.warning(\n                \"Current size is %d (max %d), so truncating data length from %d to %d\",\n                self._current_size,\n                self.max_size,\n                data_len,\n                new_size,\n            )\n            data_len = new_size\n\n        l = 0\n        try:\n            l = self._internal_write(data, data_len)\n        finally:\n            self._current_size += l\n\n        return l\n\n    def _internal_write(self, data: bytes, length: int) -&gt; int:\n        state = self.state\n        strict_parsing = self.strict_parsing\n        found_sep = self._found_sep\n\n        i = 0\n        while i &lt; length:\n            ch = data[i]\n\n            # Depending on our state...\n            if state == QuerystringState.BEFORE_FIELD:\n                # If the 'found_sep' flag is set, we've already encountered\n                # and skipped a single separator.  If so, we check our strict\n                # parsing flag and decide what to do.  Otherwise, we haven't\n                # yet reached a separator, and thus, if we do, we need to skip\n                # it as it will be the boundary between fields that's supposed\n                # to be there.\n                if ch == AMPERSAND or ch == SEMICOLON:\n                    if found_sep:\n                        # If we're parsing strictly, we disallow blank chunks.\n                        if strict_parsing:\n                            e = QuerystringParseError(\"Skipping duplicate ampersand/semicolon at %d\" % i)\n                            e.offset = i\n                            raise e\n                        else:\n                            self.logger.debug(\"Skipping duplicate ampersand/semicolon at %d\", i)\n                    else:\n                        # This case is when we're skipping the (first)\n                        # separator between fields, so we just set our flag\n                        # and continue on.\n                        found_sep = True\n                else:\n                    # Emit a field-start event, and go to that state.  Also,\n                    # reset the \"found_sep\" flag, for the next time we get to\n                    # this state.\n                    self.callback(\"field_start\")\n                    i -= 1\n                    state = QuerystringState.FIELD_NAME\n                    found_sep = False\n\n            elif state == QuerystringState.FIELD_NAME:\n                # Try and find a separator - we ensure that, if we do, we only\n                # look for the equal sign before it.\n                sep_pos = data.find(b\"&amp;\", i)\n                if sep_pos == -1:\n                    sep_pos = data.find(b\";\", i)\n\n                # See if we can find an equals sign in the remaining data.  If\n                # so, we can immediately emit the field name and jump to the\n                # data state.\n                if sep_pos != -1:\n                    equals_pos = data.find(b\"=\", i, sep_pos)\n                else:\n                    equals_pos = data.find(b\"=\", i)\n\n                if equals_pos != -1:\n                    # Emit this name.\n                    self.callback(\"field_name\", data, i, equals_pos)\n\n                    # Jump i to this position.  Note that it will then have 1\n                    # added to it below, which means the next iteration of this\n                    # loop will inspect the character after the equals sign.\n                    i = equals_pos\n                    state = QuerystringState.FIELD_DATA\n                else:\n                    # No equals sign found.\n                    if not strict_parsing:\n                        # See also comments in the QuerystringState.FIELD_DATA case below.\n                        # If we found the separator, we emit the name and just\n                        # end - there's no data callback at all (not even with\n                        # a blank value).\n                        if sep_pos != -1:\n                            self.callback(\"field_name\", data, i, sep_pos)\n                            self.callback(\"field_end\")\n\n                            i = sep_pos - 1\n                            state = QuerystringState.BEFORE_FIELD\n                        else:\n                            # Otherwise, no separator in this block, so the\n                            # rest of this chunk must be a name.\n                            self.callback(\"field_name\", data, i, length)\n                            i = length\n\n                    else:\n                        # We're parsing strictly.  If we find a separator,\n                        # this is an error - we require an equals sign.\n                        if sep_pos != -1:\n                            e = QuerystringParseError(\n                                \"When strict_parsing is True, we require an \"\n                                \"equals sign in all field chunks. Did not \"\n                                \"find one in the chunk that starts at %d\" % (i,)\n                            )\n                            e.offset = i\n                            raise e\n\n                        # No separator in the rest of this chunk, so it's just\n                        # a field name.\n                        self.callback(\"field_name\", data, i, length)\n                        i = length\n\n            elif state == QuerystringState.FIELD_DATA:\n                # Try finding either an ampersand or a semicolon after this\n                # position.\n                sep_pos = data.find(b\"&amp;\", i)\n                if sep_pos == -1:\n                    sep_pos = data.find(b\";\", i)\n\n                # If we found it, callback this bit as data and then go back\n                # to expecting to find a field.\n                if sep_pos != -1:\n                    self.callback(\"field_data\", data, i, sep_pos)\n                    self.callback(\"field_end\")\n\n                    # Note that we go to the separator, which brings us to the\n                    # \"before field\" state.  This allows us to properly emit\n                    # \"field_start\" events only when we actually have data for\n                    # a field of some sort.\n                    i = sep_pos - 1\n                    state = QuerystringState.BEFORE_FIELD\n\n                # Otherwise, emit the rest as data and finish.\n                else:\n                    self.callback(\"field_data\", data, i, length)\n                    i = length\n\n            else:  # pragma: no cover (error case)\n                msg = \"Reached an unknown state %d at %d\" % (state, i)\n                self.logger.warning(msg)\n                e = QuerystringParseError(msg)\n                e.offset = i\n                raise e\n\n            i += 1\n\n        self.state = state\n        self._found_sep = found_sep\n        return len(data)\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize this parser, which signals to that we are finished parsing,\n        if we're still in the middle of a field, an on_field_end callback, and\n        then the on_end callback.\n        \"\"\"\n        # If we're currently in the middle of a field, we finish it.\n        if self.state == QuerystringState.FIELD_DATA:\n            self.callback(\"field_end\")\n        self.callback(\"end\")\n\n    def __repr__(self) -&gt; str:\n        return \"{}(strict_parsing={!r}, max_size={!r})\".format(\n            self.__class__.__name__, self.strict_parsing, self.max_size\n        )\n</code></pre>"},{"location":"api/#python_multipart.QuerystringParser-functions","title":"Functions","text":""},{"location":"api/#python_multipart.QuerystringParser.finalize","title":"<code>finalize()</code>","text":"<p>Finalize this parser, which signals to that we are finished parsing, if we're still in the middle of a field, an on_field_end callback, and then the on_end callback.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize this parser, which signals to that we are finished parsing,\n    if we're still in the middle of a field, an on_field_end callback, and\n    then the on_end callback.\n    \"\"\"\n    # If we're currently in the middle of a field, we finish it.\n    if self.state == QuerystringState.FIELD_DATA:\n        self.callback(\"field_end\")\n    self.callback(\"end\")\n</code></pre>"},{"location":"api/#python_multipart.QuerystringParser.write","title":"<code>write(data)</code>","text":"<p>Write some data to the parser, which will perform size verification, parse into either a field name or value, and then pass the corresponding data to the underlying callback.  If an error is encountered while parsing, a QuerystringParseError will be raised.  The \"offset\" attribute of the raised exception will be set to the offset in the input data chunk (NOT the overall stream) that caused the error.</p> <p>Args:     data: The data to write to the parser.</p> <p>Returns:     The number of bytes written.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def write(self, data: bytes) -&gt; int:\n    \"\"\"Write some data to the parser, which will perform size verification,\n    parse into either a field name or value, and then pass the\n    corresponding data to the underlying callback.  If an error is\n    encountered while parsing, a QuerystringParseError will be raised.  The\n    \"offset\" attribute of the raised exception will be set to the offset in\n    the input data chunk (NOT the overall stream) that caused the error.\n\n    Args:\n        data: The data to write to the parser.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    # Handle sizing.\n    data_len = len(data)\n    if (self._current_size + data_len) &gt; self.max_size:\n        # We truncate the length of data that we are to process.\n        new_size = int(self.max_size - self._current_size)\n        self.logger.warning(\n            \"Current size is %d (max %d), so truncating data length from %d to %d\",\n            self._current_size,\n            self.max_size,\n            data_len,\n            new_size,\n        )\n        data_len = new_size\n\n    l = 0\n    try:\n        l = self._internal_write(data, data_len)\n    finally:\n        self._current_size += l\n\n    return l\n</code></pre>"},{"location":"api/#python_multipart-functions","title":"Functions","text":""},{"location":"api/#python_multipart.create_form_parser","title":"<code>create_form_parser(headers, on_field, on_file, trust_x_headers=False, config={})</code>","text":"<p>This function is a helper function to aid in creating a FormParser instances.  Given a dictionary-like headers object, it will determine the correct information needed, instantiate a FormParser with the appropriate values and given callbacks, and then return the corresponding parser.</p> <p>Args:     headers: A dictionary-like object of HTTP headers.  The only required header is Content-Type.     on_field: Callback to call with each parsed field.     on_file: Callback to call with each parsed file.     trust_x_headers: Whether or not to trust information received from certain X-Headers - for example, the file         name from X-File-Name.     config: Configuration variables to pass to the FormParser.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def create_form_parser(\n    headers: dict[str, bytes],\n    on_field: OnFieldCallback | None,\n    on_file: OnFileCallback | None,\n    trust_x_headers: bool = False,\n    config: dict[Any, Any] = {},\n) -&gt; FormParser:\n    \"\"\"This function is a helper function to aid in creating a FormParser\n    instances.  Given a dictionary-like headers object, it will determine\n    the correct information needed, instantiate a FormParser with the\n    appropriate values and given callbacks, and then return the corresponding\n    parser.\n\n    Args:\n        headers: A dictionary-like object of HTTP headers.  The only required header is Content-Type.\n        on_field: Callback to call with each parsed field.\n        on_file: Callback to call with each parsed file.\n        trust_x_headers: Whether or not to trust information received from certain X-Headers - for example, the file\n            name from X-File-Name.\n        config: Configuration variables to pass to the FormParser.\n    \"\"\"\n    content_type: str | bytes | None = headers.get(\"Content-Type\")\n    if content_type is None:\n        logging.getLogger(__name__).warning(\"No Content-Type header given\")\n        raise ValueError(\"No Content-Type header given!\")\n\n    # Boundaries are optional (the FormParser will raise if one is needed\n    # but not given).\n    content_type, params = parse_options_header(content_type)\n    boundary = params.get(b\"boundary\")\n\n    # We need content_type to be a string, not a bytes object.\n    content_type = content_type.decode(\"latin-1\")\n\n    # File names are optional.\n    file_name = headers.get(\"X-File-Name\")\n\n    # Instantiate a form parser.\n    form_parser = FormParser(content_type, on_field, on_file, boundary=boundary, file_name=file_name, config=config)\n\n    # Return our parser.\n    return form_parser\n</code></pre>"},{"location":"api/#python_multipart.parse_form","title":"<code>parse_form(headers, input_stream, on_field, on_file, chunk_size=1048576)</code>","text":"<p>This function is useful if you just want to parse a request body, without too much work.  Pass it a dictionary-like object of the request's headers, and a file-like object for the input stream, along with two callbacks that will get called whenever a field or file is parsed.</p> <p>Args:     headers: A dictionary-like object of HTTP headers.  The only required header is Content-Type.     input_stream: A file-like object that represents the request body. The read() method must return bytestrings.     on_field: Callback to call with each parsed field.     on_file: Callback to call with each parsed file.     chunk_size: The maximum size to read from the input stream and write to the parser at one time.         Defaults to 1 MiB.</p> Source code in <code>python_multipart/multipart.py</code> <pre><code>def parse_form(\n    headers: dict[str, bytes],\n    input_stream: SupportsRead,\n    on_field: OnFieldCallback | None,\n    on_file: OnFileCallback | None,\n    chunk_size: int = 1048576,\n) -&gt; None:\n    \"\"\"This function is useful if you just want to parse a request body,\n    without too much work.  Pass it a dictionary-like object of the request's\n    headers, and a file-like object for the input stream, along with two\n    callbacks that will get called whenever a field or file is parsed.\n\n    Args:\n        headers: A dictionary-like object of HTTP headers.  The only required header is Content-Type.\n        input_stream: A file-like object that represents the request body. The read() method must return bytestrings.\n        on_field: Callback to call with each parsed field.\n        on_file: Callback to call with each parsed file.\n        chunk_size: The maximum size to read from the input stream and write to the parser at one time.\n            Defaults to 1 MiB.\n    \"\"\"\n    # Create our form parser.\n    parser = create_form_parser(headers, on_field, on_file)\n\n    # Read chunks of 1MiB and write to the parser, but never read more than\n    # the given Content-Length, if any.\n    content_length: int | float | bytes | None = headers.get(\"Content-Length\")\n    if content_length is not None:\n        content_length = int(content_length)\n    else:\n        content_length = float(\"inf\")\n    bytes_read = 0\n\n    while True:\n        # Read only up to the Content-Length given.\n        max_readable = int(min(content_length - bytes_read, chunk_size))\n        buff = input_stream.read(max_readable)\n\n        # Write to the parser and update our length.\n        parser.write(buff)\n        bytes_read += len(buff)\n\n        # If we get a buffer that's smaller than the size requested, or if we\n        # have read up to our content length, we're done.\n        if len(buff) != max_readable or bytes_read == content_length:\n            break\n\n    # Tell our parser that we're done writing data.\n    parser.finalize()\n</code></pre>"},{"location":"api/#python_multipart.exceptions-classes","title":"Classes","text":""},{"location":"api/#python_multipart.exceptions.DecodeError","title":"<code>DecodeError</code>","text":"<p>               Bases: <code>ParseError</code></p> <p>This exception is raised when there is a decoding error - for example with the Base64Decoder or QuotedPrintableDecoder.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class DecodeError(ParseError):\n    \"\"\"This exception is raised when there is a decoding error - for example\n    with the Base64Decoder or QuotedPrintableDecoder.\n    \"\"\"\n</code></pre>"},{"location":"api/#python_multipart.exceptions.FileError","title":"<code>FileError</code>","text":"<p>               Bases: <code>FormParserError</code>, <code>OSError</code></p> <p>Exception class for problems with the File class.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class FileError(FormParserError, OSError):\n    \"\"\"Exception class for problems with the File class.\"\"\"\n</code></pre>"},{"location":"api/#python_multipart.exceptions.FormParserError","title":"<code>FormParserError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Base error class for our form parser.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class FormParserError(ValueError):\n    \"\"\"Base error class for our form parser.\"\"\"\n</code></pre>"},{"location":"api/#python_multipart.exceptions.MultipartParseError","title":"<code>MultipartParseError</code>","text":"<p>               Bases: <code>ParseError</code></p> <p>This is a specific error that is raised when the MultipartParser detects an error while parsing.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class MultipartParseError(ParseError):\n    \"\"\"This is a specific error that is raised when the MultipartParser detects\n    an error while parsing.\n    \"\"\"\n</code></pre>"},{"location":"api/#python_multipart.exceptions.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>FormParserError</code></p> <p>This exception (or a subclass) is raised when there is an error while parsing something.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class ParseError(FormParserError):\n    \"\"\"This exception (or a subclass) is raised when there is an error while\n    parsing something.\n    \"\"\"\n\n    #: This is the offset in the input data chunk (*NOT* the overall stream) in\n    #: which the parse error occurred.  It will be -1 if not specified.\n    offset = -1\n</code></pre>"},{"location":"api/#python_multipart.exceptions.QuerystringParseError","title":"<code>QuerystringParseError</code>","text":"<p>               Bases: <code>ParseError</code></p> <p>This is a specific error that is raised when the QuerystringParser detects an error while parsing.</p> Source code in <code>python_multipart/exceptions.py</code> <pre><code>class QuerystringParseError(ParseError):\n    \"\"\"This is a specific error that is raised when the QuerystringParser\n    detects an error while parsing.\n    \"\"\"\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0022-2026-01-25","title":"0.0.22 (2026-01-25)","text":"<ul> <li>Drop directory path from filename in <code>File</code> 9433f4b.</li> </ul>"},{"location":"changelog/#0021-2025-12-17","title":"0.0.21 (2025-12-17)","text":"<ul> <li>Add support for Python 3.14 and drop EOL 3.8 and 3.9 #216.</li> </ul>"},{"location":"changelog/#0020-2024-12-16","title":"0.0.20 (2024-12-16)","text":"<ul> <li>Handle messages containing only end boundary #142.</li> </ul>"},{"location":"changelog/#0019-2024-11-30","title":"0.0.19 (2024-11-30)","text":"<ul> <li>Don't warn when CRLF is found after last boundary on <code>MultipartParser</code> #193.</li> </ul>"},{"location":"changelog/#0018-2024-11-28","title":"0.0.18 (2024-11-28)","text":"<ul> <li>Hard break if found data after last boundary on <code>MultipartParser</code> #189.</li> </ul>"},{"location":"changelog/#0017-2024-10-31","title":"0.0.17 (2024-10-31)","text":"<ul> <li>Handle PermissionError in fallback code for old import name #182.</li> </ul>"},{"location":"changelog/#0016-2024-10-27","title":"0.0.16 (2024-10-27)","text":"<ul> <li>Add dunder attributes to <code>multipart</code> package #177.</li> </ul>"},{"location":"changelog/#0015-2024-10-27","title":"0.0.15 (2024-10-27)","text":"<ul> <li>Replace <code>FutureWarning</code> to <code>PendingDeprecationWarning</code> #174.</li> <li>Add missing files to SDist #171.</li> </ul>"},{"location":"changelog/#0014-2024-10-24","title":"0.0.14 (2024-10-24)","text":"<ul> <li>Fix import scheme for <code>multipart</code> module (#168).</li> </ul>"},{"location":"changelog/#0013-2024-10-20","title":"0.0.13 (2024-10-20)","text":"<ul> <li>Rename import to <code>python_multipart</code> #166.</li> </ul>"},{"location":"changelog/#0012-2024-09-29","title":"0.0.12 (2024-09-29)","text":"<ul> <li>Improve error message when boundary character does not match #124.</li> <li>Add mypy strict typing #140.</li> <li>Enforce 100% coverage #159.</li> </ul>"},{"location":"changelog/#0011-2024-09-28","title":"0.0.11 (2024-09-28)","text":"<ul> <li>Improve performance, especially in data with many CR-LF #137.</li> <li>Handle invalid CRLF in header name #141.</li> </ul>"},{"location":"changelog/#0010-2024-09-21","title":"0.0.10 (2024-09-21)","text":"<ul> <li>Support <code>on_header_begin</code> #103.</li> <li>Improve type hints on <code>FormParser</code> #104.</li> <li>Fix <code>OnFileCallback</code> type #106.</li> <li>Improve type hints #110.</li> <li>Improve type hints on <code>File</code> #111.</li> <li>Add type hint to helper functions #112.</li> <li>Minor fix for Field.repr #114.</li> <li>Fix use of chunk_size parameter #136.</li> <li>Allow digits and valid token chars in headers #134.</li> <li>Fix headers being carried between parts #135.</li> </ul>"},{"location":"changelog/#009-2024-02-10","title":"0.0.9 (2024-02-10)","text":"<ul> <li>Add support for Python 3.12 #85.</li> <li>Drop support for Python 3.7 #95.</li> <li>Add <code>MultipartState(IntEnum)</code> #96.</li> <li>Add <code>QuerystringState</code> #97.</li> <li>Add <code>TypedDict</code> callbacks #98.</li> <li>Add config <code>TypedDict</code>s #99.</li> </ul>"},{"location":"changelog/#008-2024-02-09","title":"0.0.8 (2024-02-09)","text":"<ul> <li>Check if Message.get_params return 3-tuple instead of str on parse_options_header #79.</li> <li>Cleanup unused regex patterns #82.</li> </ul>"},{"location":"changelog/#007-2024-02-03","title":"0.0.7 (2024-02-03)","text":"<ul> <li>Refactor header option parser to use the standard library instead of a custom RegEx #75.</li> </ul>"},{"location":"changelog/#006-2023-02-27","title":"0.0.6 (2023-02-27)","text":"<ul> <li>Migrate package installation to <code>pyproject.toml</code> (PEP 621) #54.</li> <li>Use yaml.safe_load instead of yaml.load #46.</li> <li>Add support for Python 3.11, drop EOL 3.6 #51.</li> <li>Add support for Python 3.8-3.10, drop EOL 2.7-3.5 #42.</li> <li><code>QuerystringParser</code>: don't raise an AttributeError in <code>__repr__</code> #30.</li> </ul>"}]}